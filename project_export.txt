######### filename: addc_script.ps1 #########
$password = ConvertTo-SecureString '${password}' -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential('${username}', $password)

# Install AD-Domain-Services feature
Install-WindowsFeature -Name AD-Domain-Services -IncludeManagementTools

# Promote the server to a Domain Controller
Install-ADDSForest -DomainName '${active_directory_domain}' -InstallDns -SafeModeAdministratorPassword $password -Force

# Add a DNS forwarder to firewall IP
Add-DnsServerForwarder -IPAddress '${firewall_private_ip}'

######### filename: outputs.tf #########
output "firewall_public_ip" {
  description = "Public IP address of the Azure Firewall."
  value       = azurerm_public_ip.firewall_pip.ip_address
}

######### filename: domain_controller.tf #########
locals {
  domain_controller_ip = "10.0.16.4"
  addc_script_base64 = base64encode(templatefile("${path.module}/addc_script.ps1", {
    username                = var.admin_username,
    password                = var.admin_password,
    active_directory_domain = var.active_directory_domain
    firewall_private_ip     = azurerm_firewall.primary.ip_configuration[0].private_ip_address
  }))
}

resource "azurerm_virtual_machine_extension" "dc_extension" {
  name                 = "DomainControllerExtension"
  virtual_machine_id   = azurerm_windows_virtual_machine.vms["vm-dc-${var.loc_short}-01"].id
  publisher            = "Microsoft.Compute"
  type                 = "CustomScriptExtension"
  type_handler_version = "1.9"

  protected_settings = <<SETTINGS
  {
    "commandToExecute": "powershell -command \"[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('${local.addc_script_base64}')) | Out-File -filepath dc_setup.ps1\" && powershell -ExecutionPolicy Unrestricted -File dc_setup.ps1"
  }
  SETTINGS
}

# output "decoded_script" {
#   value = base64decode(local.addc_script_base64)
# }

######### filename: log_analytics_workspace.tf #########
resource "azurerm_log_analytics_workspace" "main" {
  name                = "law-${var.loc_short}-01"
  location            = var.loc
  resource_group_name = azurerm_resource_group.mgmt.name
  sku                 = "PerGB2018"

  retention_in_days = 30
}


######### filename: vng.tf #########
# Public IP for Virtual Network Gateway
resource "azurerm_public_ip" "vng_pip" {
  name                = "pip-vng-hub-${var.loc_short}-01"
  location            = var.loc
  resource_group_name = azurerm_resource_group.hub.name
  allocation_method   = "Static"
  sku                 = "Standard"
}

# Virtual Network Gateway
resource "azurerm_virtual_network_gateway" "vng" {
  count               = var.deploy_vng ? 1 : 0
  name                = "vng-hub-${var.loc_short}-01"
  location            = var.loc
  resource_group_name = azurerm_resource_group.hub.name

  type     = "Vpn"
  vpn_type = "RouteBased"

  active_active = false
  enable_bgp    = false
  sku           = "VpnGw1"

  ip_configuration {
    name                 = "vng-ipconfig"
    public_ip_address_id = azurerm_public_ip.vng_pip.id
    subnet_id            = azurerm_subnet.hub_subnets["vnet-hub-${var.loc_short}-01/GatewaySubnet"].id
  }
}

data "http" "my_public_ip2" {
  url = "https://api.ipify.org?format=text"
}

# Local Network Gateway
resource "azurerm_local_network_gateway" "lng" {
  count               = var.deploy_vng ? 1 : 0
  name                = "lng-greghome-${var.loc_short}-01"
  location            = var.loc
  resource_group_name = azurerm_resource_group.hub.name

  gateway_address = data.http.my_public_ip2.response_body
  address_space   = var.lng_address_space
}

# VPN Connection
resource "azurerm_virtual_network_gateway_connection" "vpn_connection" {
  count                      = var.deploy_vng ? 1 : 0
  name                       = "vpn-connection-${var.loc_short}-01"
  location                   = var.loc
  resource_group_name        = azurerm_resource_group.hub.name
  virtual_network_gateway_id = azurerm_virtual_network_gateway.vng[0].id
  local_network_gateway_id   = azurerm_local_network_gateway.lng[0].id
  type                       = "IPsec"
  connection_mode            = "Default"
  connection_protocol        = "IKEv2"
  shared_key                 = var.vpn_psk
  dpd_timeout_seconds        = 45
  # see https://registry.terraform.io/providers/hashicorp/Azurerm/latest/docs/resources/virtual_network_gateway_connection#connection_protocol-1
  ipsec_policy {
    dh_group         = "DHGroup14"
    ipsec_encryption = "AES256"
    ipsec_integrity  = "SHA256"
    ike_encryption   = "AES256"
    ike_integrity    = "SHA256"
    pfs_group        = "PFS2048"
    sa_datasize      = "0"
    sa_lifetime      = "3600"
  }
}

# Output for Public IP
output "vng_public_ip" {
  value = var.deploy_vng && length(azurerm_public_ip.vng_pip) > 0 ? azurerm_public_ip.vng_pip.ip_address : null # Safeguard with conditional
}

######### filename: application_gateway.tf #########
locals {
  appgw_name                     = "appgw-hub-${var.loc_short}-01"
  appgw_public_ip_name           = "pip-appgw-hub-${var.loc_short}-01"
  frontend_port_name             = "frontendPort"
  frontend_ip_configuration_name = "frontendIP"
  backend_address_pool_name      = "backendPool"
  http_setting_name              = "backendHttpSettings"
  listener_name                  = "httpListener"
  request_routing_rule_name      = "routingRule"
  gateway_ip_configuration_name  = "appgw-ip-configuration"
}

resource "azurerm_public_ip" "appgw" {
  name                = local.appgw_public_ip_name
  location            = var.loc
  resource_group_name = azurerm_resource_group.hub.name
  allocation_method   = "Static"
  sku                 = "Standard"
}

resource "azurerm_application_gateway" "appgw" {
  name                = local.appgw_name
  location            = var.loc
  resource_group_name = azurerm_resource_group.hub.name

  sku {
    name     = "Standard_v2"
    tier     = "Standard_v2"
    capacity = 2
  }

  gateway_ip_configuration {
    name      = local.gateway_ip_configuration_name
    subnet_id = azurerm_subnet.hub_subnets["vnet-hub-${var.loc_short}-01/AppGatewaySubnet"].id
  }

  frontend_port {
    name = local.frontend_port_name
    port = 80
  }

  frontend_ip_configuration {
    name                 = local.frontend_ip_configuration_name
    public_ip_address_id = azurerm_public_ip.appgw.id
  }

  backend_address_pool {
    name         = local.backend_address_pool_name
    ip_addresses = [azurerm_network_interface.nics["vm-ws22-${var.loc_short}-01"].ip_configuration[0].private_ip_address]
  }

  backend_http_settings {
    name                  = local.http_setting_name
    cookie_based_affinity = "Disabled"
    port                  = 80
    protocol              = "Http"
    request_timeout       = 30
  }

  http_listener {
    name                           = local.listener_name
    frontend_ip_configuration_name = local.frontend_ip_configuration_name
    frontend_port_name             = local.frontend_port_name
    protocol                       = "Http"
  }

  request_routing_rule {
    name                       = local.request_routing_rule_name
    rule_type                  = "Basic"
    http_listener_name         = local.listener_name
    backend_address_pool_name  = local.backend_address_pool_name
    backend_http_settings_name = local.http_setting_name
  }

  tags = {
    environment = "dev"
  }
}




######### filename: storage.tf #########
resource "random_integer" "st" {
  min = 00
  max = 99
}

data "http" "my_public_ip" {
  url = "https://api.ipify.org?format=text"
}

resource "azurerm_storage_account" "main" {
  name                     = "stmain${var.loc_short}${random_integer.st.result}"
  resource_group_name      = azurerm_resource_group.main.name
  location                 = var.loc
  account_tier             = "Standard"
  account_replication_type = "LRS"
  account_kind             = "StorageV2"
  access_tier              = "Hot"

  https_traffic_only_enabled      = true
  allow_nested_items_to_be_public = false
  min_tls_version                 = "TLS1_2"

  network_rules {
    default_action             = "Deny"
    bypass                     = ["AzureServices"]
    ip_rules                   = [data.http.my_public_ip.response_body]
    virtual_network_subnet_ids = []
  }
}

resource "azurerm_storage_container" "test" {
  name                  = "test"
  storage_account_id    = azurerm_storage_account.main.id
  container_access_type = "private"
}

resource "azurerm_storage_share" "test" {
  name               = "test"
  storage_account_id = azurerm_storage_account.main.id
  quota              = 100
}

resource "azurerm_private_endpoint" "blob" {
  name                = "pe-blob-stmain${var.loc_short}${random_integer.st.result}"
  location            = var.loc
  resource_group_name = azurerm_resource_group.main.name
  subnet_id           = azurerm_subnet.spoke_subnets["vnet-main-${var.loc_short}-01/PrivateEndpointSubnet"].id

  private_service_connection {
    name                           = "psc-stmain${var.loc_short}${random_integer.st.result}"
    private_connection_resource_id = azurerm_storage_account.main.id
    is_manual_connection           = false
    subresource_names              = ["blob"]
  }

  private_dns_zone_group {
    name = "pdnsg-blob-stmain${var.loc_short}${random_integer.st.result}"
    private_dns_zone_ids = [
      azurerm_private_dns_zone.blob.id
    ]
  }
}

resource "azurerm_private_endpoint" "file" {
  name                = "pe-file-stmain${var.loc_short}${random_integer.st.result}"
  location            = var.loc
  resource_group_name = azurerm_resource_group.main.name
  subnet_id           = azurerm_subnet.spoke_subnets["vnet-main-${var.loc_short}-01/PrivateEndpointSubnet"].id

  private_service_connection {
    name                           = "psc-stmain${var.loc_short}${random_integer.st.result}"
    private_connection_resource_id = azurerm_storage_account.main.id
    is_manual_connection           = false
    subresource_names              = ["file"]
  }

  private_dns_zone_group {
    name = "pdnsg-file-stmain${var.loc_short}${random_integer.st.result}"
    private_dns_zone_ids = [
      azurerm_private_dns_zone.file.id
    ]
  }
}


######### filename: firewall_policy.tf #########
locals {
  all_vnets = merge(
    {
      for vnet_key, vnet in local.hub_vnets :
      vnet_key => {
        vnet_name      = vnet.vnet_name
        resource_group = vnet.resource_group
        address_space  = vnet.address_space
      }
    },
    {
      for vnet_key, vnet in local.spoke_vnets :
      vnet_key => {
        vnet_name      = vnet.vnet_name
        resource_group = vnet.resource_group
        address_space  = vnet.address_space
      }
    }
  )

  all_vnet_cidrs = flatten([
    for vnet in local.all_vnets : vnet.address_space
  ])
}


resource "azurerm_ip_group" "internal" {
  name                = "ipg-internal-${var.loc_short}"
  location            = var.loc
  resource_group_name = azurerm_resource_group.hub.name

  cidrs = local.all_vnet_cidrs
}


resource "azurerm_firewall_policy" "primary" {
  name                = "afwp-hub-${var.loc_short}-01"
  resource_group_name = azurerm_resource_group.hub.name
  location            = var.loc
  dns {
    proxy_enabled = true
    servers       = ["168.63.129.16"]
  }
}

resource "azurerm_firewall_policy_rule_collection_group" "default" {
  name               = "Azure-Default-RCG"
  firewall_policy_id = azurerm_firewall_policy.primary.id
  priority           = 2000

  network_rule_collection {
    name     = "Allow-Internal-NRC"
    priority = 1000
    action   = "Allow"

    rule {
      name                  = "East-West"
      description           = "Allow Any East-West traffic"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_ip_groups = [azurerm_ip_group.internal.id]
      destination_ports     = ["*"]
      protocols             = ["Any"]
    }

    # rule {
    #   name                  = "Any-Any"
    #   description           = "Allow Any Any traffic"
    #   source_addresses      = ["10.0.0.0/8"]
    #   destination_addresses = ["10.0.0.0/8"]
    #   destination_ports     = ["*"]
    #   protocols             = ["Any"]
    # }

    rule {
      name                  = "Onprem-Azure"
      description           = "Allow on-prem to Azure"
      source_addresses      = var.lng_address_space
      destination_ip_groups = [azurerm_ip_group.internal.id]
      destination_ports     = ["*"]
      protocols             = ["Any"]
    }

    rule {
      name                  = "Azure-Onprem"
      description           = "Allow Azure to on-prem"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = var.lng_address_space
      destination_ports     = ["*"]
      protocols             = ["Any"]
    }

  }


  network_rule_collection {
    name     = "Allow-External-NRC"
    priority = 2000
    action   = "Allow"

    rule {
      name                  = "Internet"
      description           = "Allow Any Internet"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["*"]
      destination_ports     = ["*"]
      protocols             = ["Any"]
    }

  }

}

resource "azurerm_firewall_policy_rule_collection_group" "platform" {
  name               = "Azure-Platform-RCG"
  firewall_policy_id = azurerm_firewall_policy.primary.id
  priority           = 1000

  network_rule_collection {
    name     = "Allow-Azure-Platform-Services-NRC"
    priority = 1000
    action   = "Allow"

    rule {
      name                  = "KMS"
      description           = "Allow KMS (Windows Activation)"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["23.102.135.246", "20.118.99.224", "40.83.235.53"]
      destination_ports     = ["1688"]
      protocols             = ["TCP"]
    }

    rule {
      name                  = "Azure-WireServer"
      description           = "Azure platform resources"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["168.63.129.16"]
      destination_ports     = ["80", "32526"]
      protocols             = ["TCP"]
    }

    rule {
      name              = "Windows-Time"
      description       = "Windows Time"
      source_ip_groups  = [azurerm_ip_group.internal.id]
      destination_fqdns = ["time.windows.com"]
      destination_ports = ["123"]
      protocols         = ["UDP"]
    }

    rule {
      name                  = "DNS-Inbound"
      description           = "Allow DNS Inbound"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = [azurerm_firewall.primary.ip_configuration.0.private_ip_address]
      destination_ports     = ["53"]
      protocols             = ["Any"]
    }

    rule {
      name                  = "DNS-Outbound"
      description           = "Allow DNS Outbound"
      source_addresses      = [azurerm_firewall.primary.ip_configuration.0.private_ip_address]
      destination_addresses = ["168.63.129.16"]
      destination_ports     = ["53"]
      protocols             = ["Any"]
    }

    rule {
      name                  = "Microsoft-Defender-For-Endpoint"
      description           = "Allow Microsoft Defender for Endpoint"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["MicrosoftDefenderForEndpoint"]
      destination_ports     = ["80", "443"]
      protocols             = ["Any"]
    }

    rule {
      name                  = "Microsoft-Entra-ID"
      description           = "Allow Microsoft Entra ID"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["AzureActiveDirectory"]
      destination_ports     = ["443"]
      protocols             = ["Any"]
    }

    rule {
      name                  = "Azure-Storage"
      description           = "Allow Azure Storage"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["Storage"]
      destination_ports     = ["443"]
      protocols             = ["Any"]
    }

    rule {
      name                  = "Azure-Events-Hub"
      description           = "Allow Azure Events Hub"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["EventHub"]
      destination_ports     = ["443"]
      protocols             = ["Any"]
    }

    rule {
      name                  = "Azure-Guest-And-Hybrid-Management"
      description           = "Allow Guest and Hybrid Management"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["GuestAndHybridManagement"]
      destination_ports     = ["443"]
      protocols             = ["Any"]
    }

    rule {
      name                  = "Azure-Key-Vault"
      description           = "Allow Azure Key Vault"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["AzureKeyVault"]
      destination_ports     = ["443"]
      protocols             = ["Any"]
    }

    rule {
      name                  = "Azure-Site-Recovery"
      description           = "Allow Azure Site Recovery"
      source_ip_groups      = [azurerm_ip_group.internal.id]
      destination_addresses = ["AzureSiteRecovery"]
      destination_ports     = ["443"]
      protocols             = ["Any"]
    }

  }

  application_rule_collection {
    name     = "Allow-Azure-Platform-Services-ARC"
    priority = 2000
    action   = "Allow"

    rule {
      name             = "Azure-Backup"
      source_ip_groups = [azurerm_ip_group.internal.id]
      protocols {
        type = "Https"
        port = 443
      }
      destination_fqdn_tags = ["AzureBackup"]
    }

    rule {
      name             = "Azure-Virtual-Desktop"
      source_ip_groups = [azurerm_ip_group.internal.id]
      protocols {
        type = "Https"
        port = 443
      }
      destination_fqdn_tags = ["WindowsVirtualDesktop"]
    }

    rule {
      name             = "Azure-Monitor-Agent"
      source_ip_groups = [azurerm_ip_group.internal.id]
      protocols {
        type = "Https"
        port = 443
      }
      destination_fqdns = [
        "global.handler.control.monitor.azure.com",
        "${var.loc}.handler.control.monitor.azure.com",
        "*.ods.opinsights.azure.com",
        "management.azure.com",
        "${var.loc}.monitoring.azure.com"
      ]
    }

    rule {
      name             = "Windows-Update"
      source_ip_groups = [azurerm_ip_group.internal.id]
      protocols {
        type = "Https"
        port = 443
      }
      destination_fqdn_tags = ["WindowsUpdate"]
    }

    rule {
      name             = "Windows-Diagnostics"
      source_ip_groups = [azurerm_ip_group.internal.id]
      protocols {
        type = "Https"
        port = 443
      }
      destination_fqdn_tags = ["WindowsDiagnostics"]
    }

    rule {
      name             = "MAPS"
      source_ip_groups = [azurerm_ip_group.internal.id]
      protocols {
        type = "Https"
        port = 443
      }
      destination_fqdn_tags = ["MicrosoftActiveProtectionService"]
    }

    rule {
      name             = "Certificate-Authorities"
      source_ip_groups = [azurerm_ip_group.internal.id]
      protocols {
        type = "Https"
        port = 443
      }
      destination_fqdns = [
        "cacerts.digicert.com",
        "cacerts.digicert.cn",
        "cacerts.geotrust.com",
        "www.microsoft.com",
        "crl.microsoft.com",
        "crl3.digicert.com",
        "crl4.digicert.com",
        "crl.digicert.cn",
        "cdp.geotrust.com",
        "mscrl.microsoft.com",
        "ocsp.msocsp.com",
        "ocsp.digicert.com",
        "ocsp.digicert.cn",
        "oneocsp.microsoft.com",
        "status.geotrust.com"
      ]
      # terminate_tls = true
    }
  }
}

######### filename: azure_traffic_manager.tf #########


######### filename: load_balancer.tf #########
# https://learn.microsoft.com/en-us/azure/firewall/integrate-lb



######### filename: variables.tf #########
variable "subscription_id" {
  description = "Azure subscription ID."
  type        = string
}

variable "loc" {
  description = "Azure location."
  type        = string
  default     = "uksouth"
}

variable "loc_short" {
  description = "Azure location short name."
  type        = string
  default     = "uks"
}

variable "admin_username" {
  description = "Admin username for the VMs."
  type        = string
  default     = "azureadmin"
}

variable "admin_password" {
  description = "Admin password for the VMs."
  type        = string
}

variable "active_directory_domain" {
  description = "Active Directory domain name."
  type        = string
  default     = "big.brain"
}

variable "deploy_bastion" {
  description = "Create Azure Bastion."
  type        = bool
  default     = true
}

variable "enable_nsgs" {
  description = "Enable or disable the creation of NSGs and their associations"
  type        = bool
  default     = true
}

variable "deploy_vng" {
  description = "Enable or disable the creation of a Virtual Network Gateway."
  type        = bool
  default     = false
}

variable "deploy_appgw" {
  description = "Enable or disable the creation of an Application Gateway."
  type        = bool
  default     = false
}

variable "vpn_psk" {
  description = "Pre-shared key for the VPN connection."
  type        = string
  default     = ""
}

variable "lng_address_space" {
  description = "Address space for the Local Network Gateway."
  type        = list(string)
  default     = ["192.168.0.0/16"]
}


######### filename: virtual_machines.tf #########
locals {
  windows_vms = {
    "vm-dc-${var.loc_short}-01" = {
      vnet_name          = "vnet-adds-${var.loc_short}-01"
      rg_name            = azurerm_resource_group.identity.name
      subnet_name        = "ADDSSubnet"
      private_ip_address = local.domain_controller_ip
      os                 = "WS22"
    },
    "vm-ws22-${var.loc_short}-01" = {
      vnet_name   = "vnet-main-${var.loc_short}-01"
      rg_name     = azurerm_resource_group.main.name
      subnet_name = "WindowsSubnet"
      os          = "WS22"
    }
  }
  linux_vms = {
    "vm-ubu24-${var.loc_short}-01" = {
      vnet_name   = "vnet-main-${var.loc_short}-01"
      rg_name     = azurerm_resource_group.main.name
      subnet_name = "LinuxSubnet"
      os          = "UBU24"
    }
  }

  source_image_reference_library = {
    WS22 = {
      publisher = "MicrosoftWindowsServer"
      offer     = "WindowsServer"
      sku       = "2022-Datacenter"
      version   = "latest"
    }
    UBU24 = {
      publisher = "Canonical"
      offer     = "ubuntu-24_04-lts"
      sku       = "server"
      version   = "latest"
    }
  }
}

resource "azurerm_network_interface" "nics" {
  for_each = merge(local.windows_vms, local.linux_vms)

  name                = "nic-${each.key}"
  location            = var.loc
  resource_group_name = each.value.rg_name

  ip_configuration {
    name                          = "ipconfig"
    subnet_id                     = azurerm_subnet.spoke_subnets["${each.value.vnet_name}/${each.value.subnet_name}"].id
    private_ip_address_allocation = "Dynamic"
  }
}

# Virtual Machines
resource "azurerm_windows_virtual_machine" "vms" {
  for_each = { for k, v in azurerm_network_interface.nics : k => v if contains(keys(local.windows_vms), k) }

  name                              = each.key
  resource_group_name               = local.windows_vms[each.key].rg_name
  location                          = var.loc
  size                              = "Standard_B2ms"
  admin_username                    = var.admin_username
  admin_password                    = var.admin_password
  network_interface_ids             = [each.value.id]
  vm_agent_platform_updates_enabled = true
  patch_mode                        = "AutomaticByPlatform"

  os_disk {
    name                 = "osdisk-${each.key}"
    caching              = "ReadWrite"
    storage_account_type = "StandardSSD_LRS"
  }

  source_image_reference {
    publisher = local.source_image_reference_library[local.windows_vms[each.key].os].publisher
    offer     = local.source_image_reference_library[local.windows_vms[each.key].os].offer
    sku       = local.source_image_reference_library[local.windows_vms[each.key].os].sku
    version   = local.source_image_reference_library[local.windows_vms[each.key].os].version
  }

  boot_diagnostics {
    storage_account_uri = null
  }
}

resource "azurerm_linux_virtual_machine" "vms" {
  for_each = { for k, v in azurerm_network_interface.nics : k => v if contains(keys(local.linux_vms), k) }

  name                              = each.key
  resource_group_name               = local.linux_vms[each.key].rg_name
  location                          = var.loc
  size                              = "Standard_B2ms"
  disable_password_authentication   = false
  admin_username                    = var.admin_username
  admin_password                    = var.admin_password
  network_interface_ids             = [each.value.id]
  vm_agent_platform_updates_enabled = true

  os_disk {
    name                 = "osdisk-${each.key}"
    caching              = "ReadWrite"
    storage_account_type = "StandardSSD_LRS"
  }

  source_image_reference {
    publisher = local.source_image_reference_library[local.linux_vms[each.key].os].publisher
    offer     = local.source_image_reference_library[local.linux_vms[each.key].os].offer
    sku       = local.source_image_reference_library[local.linux_vms[each.key].os].sku
    version   = local.source_image_reference_library[local.linux_vms[each.key].os].version
  }

  boot_diagnostics {
    storage_account_uri = null
  }
}


######### filename: firewall.tf #########
# Public IP for Azure Firewall
resource "azurerm_public_ip" "firewall_pip" {
  name                = "pip-azfw-hub-${var.loc_short}-01"
  resource_group_name = azurerm_resource_group.hub.name
  location            = var.loc
  allocation_method   = "Static"
  sku                 = "Standard"
}

# Azure Firewall
resource "azurerm_firewall" "primary" {
  name                = "azfw-hub-${var.loc_short}-01"
  location            = var.loc
  resource_group_name = azurerm_resource_group.hub.name

  sku_name = "AZFW_VNet"
  sku_tier = "Standard"

  ip_configuration {
    name                 = "ipconfig"
    subnet_id            = azurerm_subnet.hub_subnets["vnet-hub-${var.loc_short}-01/AzureFirewallSubnet"].id
    public_ip_address_id = azurerm_public_ip.firewall_pip.id
  }

  firewall_policy_id = azurerm_firewall_policy.primary.id
}

resource "azurerm_monitor_diagnostic_setting" "firewall_diagnostic" {
  name               = "diag-azfw-${var.loc_short}-01"
  target_resource_id = azurerm_firewall.primary.id

  log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id

  log_analytics_destination_type = "Dedicated"

  enabled_log {
    category_group = "allLogs"
  }

  metric {
    category = "AllMetrics"
  }
}


######### filename: dns.tf #########
resource "azurerm_private_dns_zone" "blob" {
  name                = "privatelink.blob.core.windows.net"
  resource_group_name = azurerm_resource_group.hub.name
}

resource "azurerm_private_dns_zone" "file" {
  name                = "privatelink.file.core.windows.net"
  resource_group_name = azurerm_resource_group.hub.name
}

resource "azurerm_private_dns_zone_virtual_network_link" "blob_link" {
  name                  = "blob-hub-vnet-link"
  resource_group_name   = azurerm_resource_group.hub.name
  private_dns_zone_name = azurerm_private_dns_zone.blob.name
  virtual_network_id    = azurerm_virtual_network.hub_vnets["vnet-hub-${var.loc_short}-01"].id
  registration_enabled  = false
}

resource "azurerm_private_dns_zone_virtual_network_link" "file_link" {
  name                  = "file-hub-vnet-link"
  resource_group_name   = azurerm_resource_group.hub.name
  private_dns_zone_name = azurerm_private_dns_zone.file.name
  virtual_network_id    = azurerm_virtual_network.hub_vnets["vnet-hub-${var.loc_short}-01"].id
  registration_enabled  = false
}

######### filename: provider.tf #########
terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = ">=4.0.0"
    }
  }
}

provider "azurerm" {
  features {}
  subscription_id = var.subscription_id
}


######### filename: bastion.tf #########
# Public IP for Azure Bastion
resource "azurerm_public_ip" "bastion_pip" {
  count               = var.deploy_bastion ? 1 : 0
  name                = "pip-bastion-hub-${var.loc_short}-01"
  resource_group_name = azurerm_resource_group.hub.name
  location            = var.loc
  allocation_method   = "Static"
  sku                 = "Standard"
}

# Azure Bastion Host
resource "azurerm_bastion_host" "bastion" {
  count               = var.deploy_bastion ? 1 : 0
  name                = "bastion-hub-${var.loc_short}-01"
  location            = var.loc
  resource_group_name = azurerm_resource_group.hub.name

  ip_configuration {
    name                 = "ipconfig"
    subnet_id            = azurerm_subnet.hub_subnets["vnet-hub-${var.loc_short}-01/AzureBastionSubnet"].id
    public_ip_address_id = azurerm_public_ip.bastion_pip[0].id
  }

  sku = "Standard"
}


######### filename: vnets_spoke.tf #########
# Local variable for the Domain Controller IP
locals {
  spoke_vnets = {
    "vnet-adds-${var.loc_short}-01" = {
      hub            = azurerm_virtual_network.hub_vnets["vnet-hub-${var.loc_short}-01"]
      vnet_name      = "vnet-adds-${var.loc_short}-01"
      location       = var.loc
      address_space  = ["10.0.16.0/20"]
      resource_group = azurerm_resource_group.identity.name
      dns_servers    = [local.domain_controller_ip]
      subnets = {
        "ADDSSubnet" = {
          address_prefix = "10.0.16.0/24"
          routes         = null
        }
        "PrivateEndpointSubnet" = {
          address_prefix = "10.0.31.0/24"
          routes         = null
        }
      }
      vnet_routes = {
        "Internet-to-Firewall" = {
          address_prefix         = "0.0.0.0/0"
          next_hop_type          = "VirtualAppliance"
          next_hop_in_ip_address = azurerm_firewall.primary.ip_configuration[0].private_ip_address
        }
        "VNetLocal-to-Firewall" = {
          address_prefix         = "10.0.16.0/20"
          next_hop_type          = "VirtualAppliance"
          next_hop_in_ip_address = azurerm_firewall.primary.ip_configuration[0].private_ip_address
        }
        "AppGatewaySubnet-to-Firewall" = {
          address_prefix         = azurerm_subnet.hub_subnets["vnet-hub-${var.loc_short}-01/AppGatewaySubnet"].address_prefixes[0]
          next_hop_type          = "VirtualAppliance"
          next_hop_in_ip_address = azurerm_firewall.primary.ip_configuration[0].private_ip_address
        }
      }
    }
    "vnet-main-${var.loc_short}-01" = {
      hub            = azurerm_virtual_network.hub_vnets["vnet-hub-${var.loc_short}-01"]
      vnet_name      = "vnet-main-${var.loc_short}-01"
      location       = var.loc
      address_space  = ["10.0.32.0/20"]
      resource_group = azurerm_resource_group.main.name
      dns_servers    = [local.domain_controller_ip]
      subnets = {
        "WindowsSubnet" = {
          address_prefix = "10.0.32.0/24"
          routes         = null
        }
        "LinuxSubnet" = {
          address_prefix = "10.0.33.0/24"
          routes         = null
        }
        "PrivateEndpointSubnet" = {
          address_prefix = "10.0.47.0/24"
          routes         = null
        }
      }
      vnet_routes = {
        "Internet-to-Firewall" = {
          address_prefix         = "0.0.0.0/0"
          next_hop_type          = "VirtualAppliance"
          next_hop_in_ip_address = azurerm_firewall.primary.ip_configuration[0].private_ip_address
        }
        "VNetLocal-to-Firewall" = {
          address_prefix         = "10.0.32.0/20"
          next_hop_type          = "VirtualAppliance"
          next_hop_in_ip_address = azurerm_firewall.primary.ip_configuration[0].private_ip_address
        }
        "AppGatewaySubnet-to-Firewall" = {
          address_prefix         = azurerm_subnet.hub_subnets["vnet-hub-${var.loc_short}-01/AppGatewaySubnet"].address_prefixes[0]
          next_hop_type          = "VirtualAppliance"
          next_hop_in_ip_address = azurerm_firewall.primary.ip_configuration[0].private_ip_address
        }
      }
    }
  }

    # Flatten subnets and prepare route table names
  spoke_subnets = flatten([
    for vnet_key, vnet in local.spoke_vnets : [
      for subnet_name, subnet in vnet.subnets : {
        key                 = "${vnet_key}/${subnet_name}"
        vnet_name           = vnet.vnet_name
        subnet_name         = subnet_name
        address_prefix      = subnet.address_prefix
        resource_group      = vnet.resource_group
        location            = vnet.location
        subnet_routes       = subnet.routes
        route_table_name    = subnet.routes != null ? "rt-${lower(replace(subnet_name, "Subnet", "sn"))}-${replace(vnet.vnet_name, "vnet-", "")}" : null
        vnet_route_table_name = vnet.vnet_routes != null ? "rt-${replace(vnet.vnet_name, "vnet-", "")}" : null
      }
    ]
  ])

  # Define Route Tables per VNet
  spoke_vnet_route_tables = {
    for vnet_key, vnet in local.spoke_vnets :
    "rt-${replace(vnet.vnet_name, "vnet-", "")}" => {
      location            = vnet.location
      resource_group_name = vnet.resource_group
      routes              = vnet.vnet_routes
      vnet_name           = vnet.vnet_name
    }
    if vnet.vnet_routes != null
  }

  # Define Route Tables per Subnet
  spoke_subnet_route_tables = {
    for subnet in local.spoke_subnets :
    subnet.route_table_name => {
      location            = subnet.location
      resource_group_name = subnet.resource_group
      routes              = subnet.subnet_routes
      vnet_name           = subnet.vnet_name
    }
    if subnet.route_table_name != null
  }

  # Merge all route tables
  spoke_all_route_tables = merge(local.spoke_vnet_route_tables, local.spoke_subnet_route_tables)
}

# Create Spoke Virtual Networks
resource "azurerm_virtual_network" "spoke_vnets" {
  for_each = local.spoke_vnets

  name                = each.value.vnet_name
  location            = each.value.location
  resource_group_name = each.value.resource_group
  address_space       = each.value.address_space
  dns_servers         = each.value.dns_servers
}

# Create Spoke Subnets
resource "azurerm_subnet" "spoke_subnets" {
  for_each = { for subnet in local.spoke_subnets : subnet.key => subnet }

  name                 = each.value.subnet_name
  address_prefixes     = [each.value.address_prefix]
  resource_group_name  = each.value.resource_group
  virtual_network_name = azurerm_virtual_network.spoke_vnets[each.value.vnet_name].name
}

# Create Spoke Route Tables
resource "azurerm_route_table" "spoke_rt" {
  for_each = local.spoke_all_route_tables

  name                = each.key
  location            = each.value.location
  resource_group_name = each.value.resource_group_name

  dynamic "route" {
    for_each = each.value.routes != null ? [for route_name, route in each.value.routes : merge(route, { name = route_name })] : []

    content {
      name                   = route.value.name
      address_prefix         = route.value.address_prefix
      next_hop_type          = route.value.next_hop_type
      next_hop_in_ip_address = lookup(route.value, "next_hop_in_ip_address", null)
    }
  }
}


locals {
  spoke_subnet_route_table_associations = {
    for subnet in local.spoke_subnets :
    subnet.key => {
      subnet_id      = azurerm_subnet.spoke_subnets[subnet.key].id
      route_table_id = (
        subnet.route_table_name != null ? azurerm_route_table.spoke_rt[subnet.route_table_name].id :
        subnet.vnet_route_table_name != null ? azurerm_route_table.spoke_rt[subnet.vnet_route_table_name].id :
        null
      )
    }
    if (
      subnet.route_table_name != null || subnet.vnet_route_table_name != null
    )
  }
}

resource "azurerm_subnet_route_table_association" "spoke_assoc" {
  for_each = local.spoke_subnet_route_table_associations

  subnet_id      = each.value.subnet_id
  route_table_id = each.value.route_table_id
}
# Peering from Spoke to Hub
resource "azurerm_virtual_network_peering" "hub_spoke" {
  for_each = local.spoke_vnets

  name                      = "peering-${each.value.vnet_name}-to-hub"
  resource_group_name       = each.value.resource_group
  virtual_network_name      = each.value.vnet_name
  remote_virtual_network_id = each.value.hub.id

  allow_virtual_network_access = true
  allow_forwarded_traffic      = true
  allow_gateway_transit        = false
  use_remote_gateways          = false
}

# Peering from Hub to Spoke
resource "azurerm_virtual_network_peering" "spoke_hub" {
  for_each = local.spoke_vnets

  name                      = "peering-hub-to-${each.value.vnet_name}"
  resource_group_name       = each.value.hub.resource_group_name
  virtual_network_name      = each.value.hub.name
  remote_virtual_network_id = azurerm_virtual_network.spoke_vnets[each.key].id

  allow_virtual_network_access = true
  allow_forwarded_traffic      = true
  allow_gateway_transit        = false
  use_remote_gateways          = false
}

# Spoke NSGs and Associations
resource "azurerm_network_security_group" "spoke_nsgs" {
  for_each = {
    for subnet in local.spoke_subnets :
    subnet.key => subnet
    if var.enable_nsgs && !contains(["AzureFirewallSubnet", "AzureBastionSubnet", "GatewaySubnet", "AppGatewaySubnet"], subnet.subnet_name)
  }

  name                = "nsg-${lower(replace(each.value.subnet_name, "Subnet", "sn"))}-${replace(each.value.vnet_name, "vnet-", "")}"
  location            = each.value.location
  resource_group_name = each.value.resource_group
}

resource "azurerm_subnet_network_security_group_association" "spoke_nsg_assoc" {
  for_each = azurerm_network_security_group.spoke_nsgs

  subnet_id                 = azurerm_subnet.spoke_subnets[each.key].id
  network_security_group_id = each.value.id
}


######### filename: vnets_hub.tf #########
# Local variable for the Domain Controller IP
locals {
  hub_vnets = {
    "vnet-hub-${var.loc_short}-01" = {
      vnet_name      = "vnet-hub-${var.loc_short}-01"
      location       = var.loc
      address_space  = ["10.0.0.0/20"]
      resource_group = azurerm_resource_group.hub.name
      dns_servers    = [local.domain_controller_ip]
      subnets = {
        "AzureFirewallSubnet" = {
          address_prefix = "10.0.0.0/24"
          routes = {
            "Internet-Out" = {
              address_prefix = "0.0.0.0/0"
              next_hop_type  = "Internet"
            }
          }
        }
        "AzureBastionSubnet" = {
          address_prefix = "10.0.1.0/24"
          routes         = null
        }
        "GatewaySubnet" = {
          address_prefix = "10.0.2.0/24"
          routes = {
            "MainVNet-to-Firewall" = {
              address_prefix         = "10.0.32.0/20"
              next_hop_type          = "VirtualAppliance"
              next_hop_in_ip_address = "10.0.0.4"
            }
            "ADDSVNet-to-Firewall" = {
              address_prefix         = "10.0.16.0/20"
              next_hop_type          = "VirtualAppliance"
              next_hop_in_ip_address = "10.0.0.4"
            }
          }
        }
        "AppGatewaySubnet" = {
          address_prefix = "10.0.3.0/24"
          routes         = null
        }
        "PrivateEndpointSubnet" = {
          address_prefix = "10.0.15.0/24"
          routes         = null
        }
      }
    }
  }

  # Flatten subnets and prepare route table names
  hub_subnets = flatten([
    for vnet_key, vnet in local.hub_vnets : [
      for subnet_name, subnet in vnet.subnets : {
        key              = "${vnet_key}/${subnet_name}"
        vnet_name        = vnet.vnet_name
        subnet_name      = subnet_name
        address_prefix   = subnet.address_prefix
        resource_group   = vnet.resource_group
        location         = vnet.location
        subnet_routes    = subnet.routes
        route_table_name = subnet.routes != null ? "rt-${lower(replace(subnet_name, "Subnet", "sn"))}-${replace(vnet.vnet_name, "vnet-", "")}" : null
      }
    ]
  ])

  # Define Route Tables per VNet
  hub_vnet_route_tables = {
    for vnet_key, vnet in local.hub_vnets :
    "rt-${replace(vnet.vnet_name, "vnet-", "")}" => {
      location            = vnet.location
      resource_group_name = vnet.resource_group
      routes              = vnet.vnet_routes
    }
    if vnet.vnet_routes != null
  }

  # Define Route Tables per Subnet
  hub_subnet_route_tables = {
    for subnet in local.hub_subnets :
    subnet.route_table_name => {
      location            = subnet.location
      resource_group_name = subnet.resource_group
      routes              = subnet.subnet_routes
    }
    if subnet.subnet_routes != null
  }

  # Merge all route tables
  hub_all_route_tables = merge(local.hub_vnet_route_tables, local.hub_subnet_route_tables)
}

# Create Hub Virtual Networks
resource "azurerm_virtual_network" "hub_vnets" {
  for_each = local.hub_vnets

  name                = each.value.vnet_name
  location            = each.value.location
  resource_group_name = each.value.resource_group
  address_space       = each.value.address_space
  dns_servers         = each.value.dns_servers
}

# Create Hub Subnets
resource "azurerm_subnet" "hub_subnets" {
  for_each = { for subnet in local.hub_subnets : subnet.key => subnet }

  name                 = each.value.subnet_name
  address_prefixes     = [each.value.address_prefix]
  resource_group_name  = each.value.resource_group
  virtual_network_name = azurerm_virtual_network.hub_vnets[each.value.vnet_name].name
}

# Create Hub Route Tables
resource "azurerm_route_table" "hub_rt" {
  for_each = local.hub_all_route_tables

  name                = each.key
  location            = each.value.location
  resource_group_name = each.value.resource_group_name

  dynamic "route" {
    for_each = [for route_name, route in each.value.routes : merge(route, { name = route_name })]

    content {
      name                   = route.value.name
      address_prefix         = route.value.address_prefix
      next_hop_type          = route.value.next_hop_type
      next_hop_in_ip_address = lookup(route.value, "next_hop_in_ip_address", null)
    }
  }
}

# Associate Route Tables with Hub Subnets
resource "azurerm_subnet_route_table_association" "hub_assoc" {
  for_each = {
    for subnet in local.hub_subnets :
    subnet.key => subnet
    if subnet.route_table_name != null
  }

  subnet_id      = azurerm_subnet.hub_subnets[each.key].id
  route_table_id = azurerm_route_table.hub_rt[each.value.route_table_name].id
}

# Hub NSGs and Associations (if needed)
resource "azurerm_network_security_group" "hub_nsgs" {
  for_each = {
    for subnet in local.hub_subnets :
    subnet.key => subnet
    if var.enable_nsgs && !contains(["AzureFirewallSubnet", "AzureBastionSubnet", "GatewaySubnet", "AppGatewaySubnet"], subnet.subnet_name)
  }

  name                = "nsg-${lower(replace(each.value.subnet_name, "Subnet", "sn"))}-${replace(each.value.vnet_name, "vnet-", "")}"
  location            = each.value.location
  resource_group_name = each.value.resource_group
}

resource "azurerm_subnet_network_security_group_association" "hub_nsg_assoc" {
  for_each = azurerm_network_security_group.hub_nsgs

  subnet_id                 = azurerm_subnet.hub_subnets[each.key].id
  network_security_group_id = each.value.id
}


######### filename: rgs.tf #########
resource "azurerm_resource_group" "hub" {
  name     = "rg-hub-${var.loc_short}-01"
  location = var.loc
}

resource "azurerm_resource_group" "identity" {
  name     = "rg-adds-${var.loc_short}-01"
  location = var.loc
}

resource "azurerm_resource_group" "main" {
  name     = "rg-main-${var.loc_short}-01"
  location = var.loc
}

resource "azurerm_resource_group" "mgmt" {
  name     = "rg-mgmt-${var.loc_short}-01"
  location = var.loc
}


# # To implement later:
# locals {
#   resource_groups = {
#     hub = {
#       name = "rg-hub-${var.loc_short}-01"
#     }
#     identity = {
#       name = "rg-adds-${var.loc_short}-01"
#     }
#     main = {
#       name = "rg-main-${var.loc_short}-01"
#     }
#     mgmt = {
#       name = "rg-mgmt-${var.loc_short}-01"
#     }
#   }
# }

# resource "azurerm_resource_group" "rgs" {
#   for_each = local.resource_groups

#   name     = each.value.name
#   location = var.loc
# }

######### Other files and directories #########
terraform.tfstate.backup
terraform.tfstate
terraform.tfvars
.terraform/
.git/
.terraform.lock.hcl
